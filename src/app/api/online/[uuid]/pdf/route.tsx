import { NextResponse, NextRequest } from "next/server";
import fs from "fs";
import { type Report, files, type EncodedPDFResponse } from "@/services/online";
import PDFDocument from "pdfkit";
import { calculateAverage } from "@/services/courses";
import {
	Semester,
	calculateAverage as calculateSemesterAverage,
} from "@/services/semesters";
import { getCourseGrade } from "@/services/grades";
import moment from "moment";

const FONTS_DIR = "public/fonts";

const semestersDates = [
	{
		name: "T5",
		start: "2023-09-12",
		end: "2024-02-12",
	},
	{
		name: "T6",
		start: "2024-02-12",
		end: "2024-08-12",
	},
	{
		name: "T7",
		start: "2024-08-12",
		end: "2025-02-12",
	},
	{
		name: "T8",
		start: "2025-02-12",
		end: "2025-08-12",
	},
	{
		name: "T9",
		start: "2025-08-12",
		end: "2026-02-12",
	},
	{
		name: "T10",
		start: "2026-02-12",
		end: "2026-08-12",
	},
];

const fonts = {
	daytona: {
		regular: `${FONTS_DIR}/DaytonaPro-Regular.ttf`,
		bold: `${FONTS_DIR}/DaytonaPro-Bold.ttf`,
		sm: `${FONTS_DIR}/DaytonaPro-Semibold.ttf`,
		light: `${FONTS_DIR}/DaytonaPro-Light.ttf`,
		thin: `${FONTS_DIR}/DaytonaPro-Thin.ttf`,
	},
};

const formatDate = (date: string) => moment(date).format("DD/MM/YYYY");

const header = (doc: PDFKit.PDFDocument, semester: Semester) => {
	doc
		.font(fonts.daytona.bold)
		.fontSize(30)
		.text("EPIGRADES", 0, 25, {
			align: "center",
		})
		.moveDown();

	let { start, end } = semestersDates.find((s) => s.name === semester.name) || {
		start: "",
		end: "",
	};

	doc
		.font(fonts.daytona.thin)
		.fontSize(10)
		.text(
			`Semestre ${semester.name} - du ${formatDate(start)} au ${formatDate(
				end
			)}`,
			0,
			65,
			{
				align: "center",
			}
		);
};

const footer = (doc: PDFKit.PDFDocument) => {
	doc
		.font(fonts.daytona.thin)
		.fontSize(10)
		.text("Generated by @AlxisHenry - Epigrades", 0, doc.page.height - 35, {
			align: "center",
		});
};

const pdf = (uuid: string, grades: Report): Promise<string> => {
	const report = new PDFDocument({
		font: fonts.daytona.regular,
		margins: {
			top: 20,
			bottom: 20,
			left: 20,
			right: 20,
		},
	});

	return new Promise<string>((resolve, reject) => {
		let file = files.temp.report(uuid);
		let pendingStepCount = 2;

		const stepFinished = () => {
			if (--pendingStepCount == 0) {
				resolve(fs.readFileSync(file, "base64"));
				fs.unlinkSync(file);
			}
		};

		const stream = fs.createWriteStream(file);
		stream.on("close", stepFinished);
		report.pipe(stream);

		let semestersCount = grades.semesters.length;

		for (let semester of grades.semesters) {
			header(report, semester);
			footer(report);

			report.font(fonts.daytona.bold).fontSize(20).text(
				`${grades.student.name} - ${grades.student.email}`,
			);

			if (!semester.courses.length) continue;

			for (let course of semester.courses) {
				let courseAverage = calculateAverage(course);
				if (courseAverage === "-") continue;
				let grade = getCourseGrade(course);


				report
					.font(fonts.daytona.regular)
					.text(
						`${course.name} - ${courseAverage} - ${grade === "-" ? "N/A" : grade}`
					);
			}

			if (--semestersCount > 0) report.addPage();
		}

		report.end();
		stepFinished();
	});
};

export async function GET(
	request: NextRequest,
	route: {
		params: {
			uuid: string;
		};
	}
): Promise<NextResponse<EncodedPDFResponse>> {
	let { uuid } = route.params;
	let file = files.reports(uuid);

	if (!fs.existsSync(file)) {
		return NextResponse.json({
			base64: null,
		});
	}

	let report: Report = JSON.parse(fs.readFileSync(file, "utf8"));

	return NextResponse.json({
		base64: await pdf(uuid, report),
	});
}
