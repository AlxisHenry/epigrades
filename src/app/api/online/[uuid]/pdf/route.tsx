import { NextResponse, NextRequest } from "next/server";
import fs from "fs";
import { type Report, files, type EncodedPDFResponse } from "@/services/online";
import PDFDocument from "pdfkit";
import { calculateAverage } from "@/services/courses";
import { calculateAverage as calculateSemesterAverage } from "@/services/semesters";
import { getCourseGrade } from "@/services/grades";

const FONTS_DIR = "public/fonts";

const fonts = {
	daytona: {
		regular: `${FONTS_DIR}/DaytonaPro-Regular.ttf`,
		bold: `${FONTS_DIR}/DaytonaPro-Bold.ttf`,
		sm: `${FONTS_DIR}/DaytonaPro-Semibold.ttf`,
		light: `${FONTS_DIR}/DaytonaPro-Light.ttf`,
		thin: `${FONTS_DIR}/DaytonaPro-Thin.ttf`,
	},
};

const footer = (doc: PDFKit.PDFDocument) => {
	doc
		.font(fonts.daytona.thin)
		.fontSize(10)
		.text(
			"Generated by @AlxisHenry - Epigrades",
			0,
			doc.page.height - 35,
			{ align: "center" }
		);
}

const pdf = (uuid: string, grades: Report): Promise<string> => {
	const report = new PDFDocument({
		font: fonts.daytona.regular,
		margins: {
			top: 20,
			bottom: 20,
			left: 20,
			right: 20,
		},
	});

	return new Promise<string>((resolve, reject) => {
		let file = files.temp.report(uuid);
		let pendingStepCount = 2;

		const stepFinished = () => {
			if (--pendingStepCount == 0) {
				resolve(fs.readFileSync(file, "base64"));
				fs.unlinkSync(file);
			}
		};

		const stream = fs.createWriteStream(file);
		stream.on("close", stepFinished);
		report.pipe(stream);

		report.fontSize(12).font(fonts.daytona.bold).text("Report", 50, 50);

		let multiplePages = grades.semesters.length > 1;

		for (let semester of grades.semesters) {
			footer(report);

			if (!semester.courses.length) continue;
			report
				.font(fonts.daytona.sm)
				.text(
					`${semester.name} - ${calculateSemesterAverage(semester)}`,
					50,
					100
				);
			for (let course of semester.courses) {
				if (calculateAverage(course) === "-") continue;
				let grade = getCourseGrade(course);
				report
					.font(fonts.daytona.regular)
					.text(
						`${course.name} - ${calculateAverage(course)} - ${grade === "-" ? "N/A" : grade
						}`
					);

				report
					.font(fonts.daytona.regular)
					.text(
						`${course.name} - ${calculateAverage(course)} - ${grade === "-" ? "N/A" : grade
						}`
					);

				report
					.font(fonts.daytona.regular)
					.text(
						`${course.name} - ${calculateAverage(course)} - ${grade === "-" ? "N/A" : grade
						}`
					);

				report
					.font(fonts.daytona.regular)
					.text(
						`${course.name} - ${calculateAverage(course)} - ${grade === "-" ? "N/A" : grade
						}`
					);

				report
					.font(fonts.daytona.regular)
					.text(
						`${course.name} - ${calculateAverage(course)} - ${grade === "-" ? "N/A" : grade
						}`
					);

				report
					.font(fonts.daytona.regular)
					.text(
						`${course.name} - ${calculateAverage(course)} - ${grade === "-" ? "N/A" : grade
						}`
					);

				report
					.font(fonts.daytona.regular)
					.text(
						`${course.name} - ${calculateAverage(course)} - ${grade === "-" ? "N/A" : grade
						}`
					);

				report
					.font(fonts.daytona.regular)
					.text(
						`${course.name} - ${calculateAverage(course)} - ${grade === "-" ? "N/A" : grade
						}`
					);
			}

			if (multiplePages) report.addPage();
		}

		report.end();
		stepFinished();
	});
};

export async function GET(
	request: NextRequest,
	route: {
		params: {
			uuid: string;
		};
	}
): Promise<NextResponse<EncodedPDFResponse>> {
	let { uuid } = route.params;
	let file = files.reports(uuid);

	if (!fs.existsSync(file)) {
		return NextResponse.json({
			base64: null,
		});
	}

	let report: Report = JSON.parse(fs.readFileSync(file, "utf8"));

	return NextResponse.json({
		base64: await pdf(uuid, report),
	});
}
